[
  {
    "timestamp": "2025-09-25T06:26:02.656229",
    "type": "text",
    "content": "[File: labsheet3.pdf]\nQueues \n-By Sachin.S \n23MIA1114 \n1) Implement the queue operations in C \nProgram: \n#include  <stdio.h>  \nint queue[50]; \nint rear = - 1; \nint front = - 1; \nvoid enqueue (){ \n    int add_item ; \n    if (rear == 49) \n    printf(\"Queue Overflow \\n\"); \n    else{ \n        if (front == - 1) \n        front = 0; \n        printf(\"Inset the element in queue : \" ); \n        scanf(\"%d\", &add_item ); \n        rear = rear + 1; \n        queue[rear] = add_item ;}}   \nvoid dequeue (){ \n    if (front == - 1 || front > rear){ \n        printf(\"Queue Underflow \\n\"); \n        return ;} \n    else{ \n        printf(\"Element deleted from queue is : %d\\n\", queue[front]); \n        front = front + 1;}} \nvoid main(){ \n    int choice; \n    while (1){ \n        printf(\"1.Insert element to queue \\n\"); \n        printf(\"2.Delete element from queue \\n\"); \n        printf(\"3.Quit \\n\"); \n        printf(\"Enter your choice : \" ); \n        scanf(\"%d\", &choice); \n        switch (choice){ \n            case 1: \n            enqueue (); \n            break; \n            case 2:             dequeue (); \n            break; \n            case 3: \n            exit(0); \n            default : \n            printf(\"Wrong choice \\n\");}}}  \n \nOutput: \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n2. Implement Circular queue operations in C. \nProgram:  \n#include  <stdio.h>  \nint items[50],front = -1, rear = -1; \nint isFull() { \n  if ((front == rear + 1) || (front == 0 && rear ==  49))  \n  return 1; \n  return 0;} \nint isEmpty () { \n  if (front == -1) \n   return 1; \n  return 0;} \nvoid enqueue (int element ) { \n  if (isFull()) \n    printf(\"Queue is full!! \\n\"); \n  else { \n    if (front == -1)  \n    front = 0; \n    rear = (rear + 1) % 50; \n    items[rear] = element ;}} \nvoid dequeue () { \n  int element ; \n  if (isEmpty ()) { \n    printf(\"Queue is empty !! \\n\");}  \n  else { \n    element  = items[front]; \n    if (front == rear) { \n      front = -1; \n      rear = -1;}  \nelse { \n      front = (front + 1) % 50;}}} \nvoid main(){ \n  int choice,temp; \nwhile(1){ \n        printf(\"1.add element to queue \\n2.delete element from queue \\n3.exit\\n\"); \n        scanf(\"%d\",&choice); \n        switch (choice){ \n        case 1: \n        scanf(\"%d\",&temp); \n        enqueue (temp); \n        break; \n        case 2: \n        dequeue (); \n        break; \n        case 3: \n        exit(0); \n        default : \n        printf(\"enter choice correctly \\n\"); \n        break;}} \nreturn 0;} \n \nOutput:  \n3.Let Q be a Queue data structure and it has \u2018n \u2018 elements. Write a program \nto print elements  from the Queue  Q which are greater than p . Print \u201cno\u201d \nif every element of the Queue is  less than or equal to p.  For example, \nyour code produces output  44, 15 if the queue Q has   10, 2,13,44,15 ( \nassume 10 is the front element of the queue) elements  and p=14.  Note: \nUse Enqueue and Dequeue operations only. \nProgram:  \n#include  <stdio.h>  \n#include  <stdbool.h>  \n#define  max 100 \nint queue[max]; \nint front=-1; \nint rear=-1; \nbool isempty (){ \n    return front==-1;} \nvoid enqueue (int element ){ \n    if (rear==max-1){ \n        printf(\"error queue is full \\n\"); \n        return;} \n    if(front==-1){ \n        front=0;} \n    rear++; \n    queue[rear]=element ;} \nint dequeue (){ \n    if(isempty ()){ \n        printf(\"error queue is empty \\n\"); \n        return -1;} \n    int element =queue[front]; \n    if(front==rear){ \n        front=rear=-1;} \n    else{ \n        front++;} \n    return element ;} \nint main(){ \n    int n; \n    int p; \n    printf(\"enter the number of elements in the queue: \" ); \n    scanf(\"%d\",&n); \n    printf(\"enter the elements of the queue: \\n\"); \n    for(int i=0;i<n;i++){ \n        int element ; \n        scanf(\"%d\",&element ); \n        enqueue (element );} \n    printf(\"enter the thershold value :\" ); \n    scanf(\"%d\",&p); \n    bool foundgreater =0; \n    printf(\"elements greater than %d: \",p); \n    while(!isempty ()){ \n        int element  =dequeue (); \n        if(element >p){ \n            printf(\"%d \",element ); \n            foundgreater =1;}} \n    if(!foundgreater ){ \n        printf(\"no\");} \n    return 0;} \n \nOutput: \n \n4.Let Q be a Queue data structure and it has \u2018n \u2018 elements.  A D_QUE is \na double ended queue and it allows insertion and deletion at both \nends.  Assume X 1, X2, \u2026, X n  are n-positive integers.  Write an \nalgorithm  and subsequent C code to insert element all even numbers at \none end of a  D_QUE and  all odd integers at another end  of a D_QUE. \nProgram: \n#include  <stdio.h>  \n#include  <stdlib.h>  \n#define  MAX 100 \ntypedef  struct { \n    int data[MAX]; \n    int front; \n    int rear;} D_QUE; \nvoid initDQue (D_QUE* queue) { \n    queue->front = -1; \n    queue->rear = -1;} \nvoid enqueueFront (D_QUE* queue, int data) { \n    if ((queue->front == 0 && queue->rear == MAX - 1) || (queue->rear + 1 == \nqueue->front)) { \n        printf(\"Queue is full. \\n\"); \n        return;} \n    if (queue->front == -1) { \n        queue->front = 0; \n        queue->rear = 0;}  \nelse if (queue->front == 0) { \n        queue->front = MAX - 1; \n    } else { \n        queue->front--;} \n    queue->data[queue->front] = data;} \nvoid enqueueRear (D_QUE* queue, int data) { \n    if ((queue->front == 0 && queue->rear == MAX - 1) || (queue->rear + 1 == \nqueue->front)) { \n        printf(\"Queue is full. \\n\"); \n        return;} \n    if (queue->front == -1) { \n        queue->front = 0; \n        queue->rear = 0; \n    } else if (queue->rear == MAX - 1) { \n        queue->rear = 0; \n    } else { \n        queue->rear++;} \n    queue->data[queue->rear] = data;} void printDQue (D_QUE* queue) { \n    if (queue->front == -1) { \n        printf(\"Queue is empty. \\n\"); \n        return;} \n    int i = queue->front; \n    while (i != queue->rear) { \n        printf(\"%d \", queue->data[i]); \n        i = (i + 1) % MAX;} \n    printf(\"%d\\n\", queue->data[queue->rear]);} \nvoid insertEvenOdd (D_QUE* queue, int* arr, int n) { \n    for (int i = 0; i < n; i++) { \n        if (arr[i] % 2 == 0) { \n            enqueueRear (queue, arr[i]); \n        } else { \n            enqueueFront (queue, arr[i]);}}} \nint main() { \n    int arr[] = {1, 2, 3, 4, 5, 6}; \n    int n = sizeof(arr) / sizeof(arr[0]); \n    D_QUE queue; \n    initDQue (&queue); \n    insertEvenOdd (&queue, arr, n); \n    printDQue (&queue); \n    return 0;} \n \n \n\nAdd your prompt here:",
    "processed": true,
    "steps": [
      {
        "domain": "Text Analysis",
        "details": "Analyzing input content",
        "output": "Input analyzed successfully"
      },
      {
        "domain": "Context Processing",
        "details": "Processing context and relationships",
        "output": "Context processed successfully"
      },
      {
        "domain": "Response Generation",
        "details": "Generating appropriate response",
        "output": "Response generated successfully"
      },
      {
        "domain": "File Processing",
        "details": "Processing application/pdf file",
        "output": "File processed successfully"
      }
    ]
  }
]